\documentclass[12pt,twoside]{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[italian]{babel}

\usepackage[a4paper,margin=1in]{geometry}

\usepackage{listings}

\usepackage{amsmath}

\usepackage{tabularx}

\usepackage{tikz}

\usepackage{float}

\lstdefinelanguage{fabula}{
  keywordstyle=\textbf,
  keywords={div,if,mod},
  basicstyle=\ttfamily,
  keepspaces=true,
  frame=single,
  numbers=left,
  stepnumber=1,
  extendedchars=true,
  literate=
    {ᐅ}{$\texttt{\triangleright}$}1
    {≥}{$\texttt{\geq}$}1
    {≤}{$\texttt{\leq}$}1
    {≠}{$\texttt{\neq}$}1
}

\lstset{language=fabula}

\DeclareUnicodeCharacter{1405}{$\triangleright$}
\DeclareUnicodeCharacter{2265}{$\geq$}
\DeclareUnicodeCharacter{2264}{$\leq$}
\DeclareUnicodeCharacter{2260}{$\neq$}

\title{Laboratorio di Intelligenza Artificiale}
\author{Andrea Ciccarello}
\date{A.A. 2024-2025}

\begin{document}

\maketitle

\section*{Esercizio 1}

\paragraph{Problema.} Il problema consiste nel creare un ragionatore in logica proposizionale, sfruttando regole e implicazioni logiche. Queste regole sono espresse sotto forma di implicazioni logiche (ad esempio, \emph{se A allora B}), e l'obiettivo del ragionatore è applicare tali regole in modo sistematico per estendere un insieme di condizioni iniziali fino a raggiungere le condizioni finali desiderate.

Il cuore di questo sistema è il motore inferenziale, un componente che applica meccanismi di inferenza per dedurre nuove informazioni a partire da un insieme di fatti e regole.
Un ragionatore deve essere in grado di gestire le complessità delle regole logiche e applicare in modo efficiente le inferenze, rispettando la correttezza logica e garantendo la validità delle deduzioni.
Il compito del programma in \textit{Fabula} sarà quello di analizzare le regole (espresse come implicazioni) e applicarle per raggiungere le conclusioni desiderate, espandendo progressivamente il set di fatti noti. 

Le implicazioni vengono espresse come una congiunzione di ipotesi (gli antecedenti) che generano dei fatti nuovi del tipo:

\[
\text{antecedente1}_1 \land \text{antecedente1}_2 \land \ldots \land \text{antecedente1}_N \rightarrow \text{tesi1}_1
\]
\[
\text{antecedente2}_1 \land \text{antecedente2}_2 \land \ldots \land \text{antecedente2}_N \rightarrow \text{tesi2}_1
\]

Esse vengono espresse con una lista di termini \texttt{impl(antecedente,tesi)}. Gli antecedenti vengono rappresentati tramite degli una lista di and. I goal sono rappresentati da uno o più proposizioni all'interno di un or logico.
La signature della funzione ad alto livello, che successivamente verrà implementata nel linguaggio logico funzionale \textit{Fabula} dovrà essere la seguente:

\begin{lstlisting}
check([Lista di antecedenti e tesi], 
    [Lista di fatti veri],[Goal])
\end{lstlisting}

Il ragionatore ha 2 strade da poter intraprendere per poter risolvere questo problema:
\begin{enumerate}
    \item \textit{Ragionamento in avanti}: partendo da un certo insieme di regole generare tutte le nuove verità, partendo da un insieme di fatti veri.
    \item \textit{Ragionamento indietro}: con l'obiettivo di rendere vero un fatto, quali regole poter applicare e sotto quali condizioni posso portare a quel fatto.
\end{enumerate}

\paragraph{Metodo.} L'algoritmo alla base di check\_fwd/3 è una variante della catena in avanti (forward chaining), uno dei due principali metodi di ragionamento usati da un motore inferenziale.
Essa è tecnica di inferenza utilizzata in sistemi basati su regole. Partendo da un di fatti (le condizioni iniziali) e applicare ripetutamente regole di inferenza per dedurre nuovi fatti, finché non si raggiunge un obiettivo preposto.
Un motore inferenziale è un algoritmo che simula le modalità con cui la mente umana trae delle conclusioni logiche attraverso il ragionamento.

\begin{enumerate}
    \item Si parte dai fatti noti espressi nel secondo campo del check\_fwd/3.
    \item Si controlla se le le regole che sono già presenti al momento già permettono di arrivare al goal finale.
    \item Si leggono le regole e le si verifica rispetto alle precondizioni date.
    \item Si allarga l'insieme delle proposizioni vere, aggiungendo eventualmente quelle presenti all'interno delle implicazioni.
    \item Si ricomincia dal punto 2
\end{enumerate}

\paragraph{Strutture dati.} Vengono utilizzate diverse strutture dati differenti la cui base sono le liste implementate nel linguaggio \texttt{Fabula}.
\begin{enumerate}
    \item Liste: Per rappresentare insiemi di implicazioni, condizioni iniziali e finali.
    \item Operatori logici (\texttt{and},\texttt{or}): Rappresentati come alberi binari di espressioni logiche.
    \item Implicazioni \texttt{impl(A, B)}: Strutture che rappresentano regole logiche.
    \item Le implicazioni che non possono ancora essere verificate, per la mancanza della veridicità di uno o più antecedenti, vengono inserite in una lista con regole di gestione FIFO, simile a quello che accade in uno Stack. 
\end{enumerate}

Le implicazioni (\texttt{impl(A, B)}) possono contenere uno o più \texttt{and()} annidati, in modo simile il goal finale potrebbe essere rappresentato da uno o più proposizioni dentro ad uno o più \texttt{or()} annidati.

\paragraph{Funzioni.} 

All'utente finale verrà esposta soltanto una funzione check/3, al cui interno inserirà nei rispettivi campi
\begin{enumerate}
    \item La lista delle implicazioni sfruttando il termine impl(A,B).
    \item La lista delle regole iniziali, rappresentata da una lista di proposizione, da cui partire per effettuare la computazione.
    \item la lista delle regole finali che rappresentano l'obiettivo da raggiungere.
\end{enumerate}

\begin{lstlisting}
ᐅ check/3 function
check(ListaImpl, RegoleIniziali, Goal) 
    if check_fwd(ListaImpl,[], RegoleIniziali, Goal)

\end{lstlisting}
L'implementazione del ragionatore tramite il  "Forward chaining" viene implementato tramite la funzione check\_fwd/3, la signature è simile alla check tranne per il secondo elemento che rappresenta lo Stack delle regole che si sono rivelate false fino a quel momento.

\begin{lstlisting}
ᐅ check_fwd/3 function pravate
check_fwd(__,_, X,Y) if anyMember(Y, X)

\end{lstlisting}

I 2 casi in cui la funziona termina con successo sono quelli in cui almeno un termine del goal è presente all'interno delle proposizioni verificate come vere. 

\begin{lstlisting}

ᐅ check_fwd/3 function first case 
check_fwd([impl(ListaAnd,C
          StackImplicazioniFalse, 
          RegoleIniziali, 
          RegoleFinali) =
    check_fwd(StackImplicazioniFalse,
              [], 
              append(RegoleIniziali, 
              [normalizeNot(C)]), 
              RegoleFinali) 
    if subset(andList(ListaAnd), 
              RegoleIniziali)
\end{lstlisting}

Nel caso in cui sia presente soltanto una implicazione la si verifica, si normalizza la tesi se necessario e in caso positivo si amplia la lista delle proposizioni vere. Se la verifica è positiva si spostano le eventuali regole reputate false e le si inserisce all'interno delle regole da verificare.

\begin{lstlisting}
ᐅ check_fwd/3 function second case 
check_fwd([impl(ListaAnd, C) | T], 
          StackImplicazioniFalse, 
          RegoleIniziali, 
          RegoleFinali) =
    check_fwd([StackImplicazioniFalse | T], 
              [], append(RegoleIniziali, 
              [normalizeNot(C)]), RegoleFinali) 
    if subset(andList(ListaAnd), 
              RegoleIniziali)
\end{lstlisting}

Se la lista delle implicazioni è composta ancora da più di un elemento si verifica la prima e nel caso si amplia la lista delle regole vere e si accoda il resto delle regole alla coda "First in First out" delle regole reputate come false in precedenza.
Questo fa si che la prossima computazione provi a verificare prima le regole che in precedenza non avevano tutti i propri antecedenti rispettati. 

\begin{lstlisting}
ᐅ check_fwd/3 function third case 
check_fwd([H | T], 
          StackImplicazioniFalse, 
          RegoleIniziali, 
          RegoleFinali) 
    if check_fwd(T, [H | StackImplicazioniFalse], 
                 RegoleIniziali, 
                 RegoleFinali)
\end{lstlisting}

Come ultimo caso se la implicazione non rientra in nessuno dei casi precedenti allora la si inserisce nella lista delle regole false che funziona come una coda FIFO. Questa lista è presente nel secondo argomento di check\_fwd.


\paragraph{Esempi.} Descrizione di alcuni esempi di utilizzo della funzione check.
% Appunti dei test
% check([impl(and(a, b), c), impl(and(a, c), d)], [a, b], [d]) -> true
% check([impl(and(a, c), d), impl(and(a, b), c)], [a, b], [d]) -> true (stack delle regole false!!!)

% check([impl(and(a, b), c)], [a, b], [d]) -> no more results
% check([impl(and(a, b), c), impl(and(a, b), c)], [a, b], [d]) -> no more results

% check([], [a, b], [a]) -> true
% check([], [a, b,c], [a,d]) -> true

% check([impl(and(and(a, b), c), d)], [a, b, c], [d]) -> true
% check([impl(and(and(a, b), c), d), impl(and(c,d), e)], [a, b, c], [e]) -> true


\begin{table}[ht]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Check} & \textbf{Risultato} \\ \hline
\texttt{check([impl(and(a, c), d), impl(and(a, b), c)], [a, b], [d])}\textsuperscript{1} & true \\ \hline
\texttt{check([impl(and(a, b), c), impl(and(a, c), d)], [a, b], [d])}\textsuperscript{2} & true \\ \hline
\texttt{check([impl(and(a, b), c)], [a, b], [d])}\textsuperscript{3} & NMR \\ \hline
\texttt{check([impl(and(a, b), c), impl(and(a, b), c)], [a, b], [d])}\textsuperscript{4} & NMR \\ \hline
\texttt{check([],[a, b],[a])}\textsuperscript{5} & true \\ \hline
\texttt{check([],[a, b, c],[a, d])}\textsuperscript{6} & true \\ \hline
\texttt{check([impl(and(and(a, b), c), d)], [a, b, c], [d])}\textsuperscript{7} & true \\ \hline
\texttt{check([impl(and(and(a,b),c),d),impl(and(c,d),e)],[a,b,c],[e])}\textsuperscript{8} & true \\ \hline
\end{tabular}
\caption{Risultati dei test esercizio 1}
\end{table}


Vengono presi in esame diverse combinazioni di liste di implicazioni, regole da cui partire e goal. Questa breve lista serve a esplicitare in quali casi il check riesca ad applicare le regole ed arrivare all'obiettivo preposto.
Quando si ottiene un NMR\textsuperscript{3,4} ("no more results") significa che l'interprete del linguaggio non è riuscito ad arrivare ad un risultato positivo e quindi non è stato possibile trovare almeno un goal appartenente all'insieme dei fatti ampliati.
Il primo esempio\textsuperscript{1} mostra come il ragionatore sia capace di arrivare al goal preposto (d) anche se le regole non sono ordinate, questo è possibile grazie allo stack delle implicazioni che inizialmente sono risultate come non verificabili.
Quinto\textsuperscript{5} e sesto\textsuperscript{6} esempio sono i casi in cui il check è già verificato senza dover fare alcun passo e quindi daranno subito \texttt{true}.

\cleardoublepage

\section*{Esercizio 2}

\paragraph{Problema.} In questo esercizio viene analizzato il problema della pianificazione, partendo da uno stato iniziale del mondo e cercando di arrivare a uno stato finale desiderato, definito come stato Goal. Ogni azione è caratterizzata da:
\begin{enumerate}
    \item Nome univoco
    \item Precondizione (sottoinsieme dello stato del mondo)
    \item Postcondizione (sottoinsieme dello stato del mondo risultante dopo l'azione)
    \begin{itemize}
        \item Quelli che vengono rimossi dallo stato del mondo (post condizioni delete)
        \item Quelli che vengono aggiunti allo stato del mondo (post condizioni add)
    \end{itemize}
\end{enumerate}

Esempi di azioni:
\begin{enumerate}
    \item \texttt{grab(X)}: afferra il blocco X
    \item \texttt{put(X,Y)}: posiziona il blocco X su Y
    \item \texttt{putOnTable(X)}: posiziona il blocco X sul tavolo
\end{enumerate}


In seguito andrò ad elencare le azioni che possono essere intraprese con le relative precondizioni e post condizioni da applicare alla lista degli stati.

\begin{enumerate}
    \item \texttt{grab(X)}:
    \begin{itemize}
        \item \textbf{Precondizioni:} \texttt{empty, clear(X)}
        \item \textbf{Post condizioni delete:} \texttt{empty}
        \item \textbf{Post condizioni add:} \texttt{holding(X)}
    \end{itemize}

    \item \texttt{put(X,Y)}:
    \begin{itemize}
        \item \textbf{Precondizioni:} \texttt{holding(X), clear(Y)}
        \item \textbf{Post condizioni delete:} \texttt{holding(X), clear(Y)}
        \item \textbf{Post condizioni add:} \texttt{empty, clear(X), on(X,Y)}
    \end{itemize}

    \item \texttt{putOnTable(X)}:
    \begin{itemize}
        \item \textbf{Precondizioni:} \texttt{holding(X)}
        \item \textbf{Post condizioni delete:} \texttt{holding(X)}
        \item \textbf{Post condizioni add:} \texttt{empty, clear(X), onTable(X)}
    \end{itemize}
\end{enumerate}

\textbf{Stati:}
I predicati per descrivere gli stati sono rappresentati come liste e includono le seguenti descrizioni:
\begin{itemize}
    \item \texttt{on(X,Y)}: il blocco X è appoggiato su Y
    \item \texttt{onTable(X)}: il blocco X è sul tavolo
    \item \texttt{empty}: il braccio è libero
    \item \texttt{holding(X)}: il braccio ha in mano il blocco X
    \item \texttt{clear(X)}: il blocco X è libero e non ha nulla sopra
\end{itemize}

Gli stati verranno inseriti all'interno della rappresentazione corrente e futura del mondo che poi dovranno essere elaborati dal pianificatore per poter applicare le azioni ed avere il goal a cui puntare.

\textbf{Esempio di stato iniziale:}
\begin{center}
    [empty, on(b3,b1), onTable(b1), onTable(b2), clear(b3), clear(b2)]
\end{center}

\textbf{Esempio di stato finale:}
\begin{center}
    [empty, on(b1,b2), on(b2,b3), onTable(b3), clear(b1)]
\end{center}

La funzione block permette di dichiarare quali e quanti sono i blocchi sono presenti sul tavolo.
La funzione \texttt{block(X)} può essere definita come segue:
\begin{itemize}
    \item \texttt{block(X)} if \texttt{X = b1}
    \item \texttt{block(X)} if \texttt{X = b2}
    \item \texttt{block(X)} if \texttt{X = b3}
\end{itemize}
oppure in forma semplificata:
\begin{itemize}
    \item \texttt{block(b1)}
    \item \texttt{block(b2)}
    \item \texttt{block(b3)}
\end{itemize}

Se per esempio si prova a controllare quali blocchi sono presenti sul tavolo tramite la query \texttt{[block(X), X]} il risultato sarà \texttt{[true,b1], [true,b2], [true,b3]}.

\paragraph{Metodo.} Il metodo sviluppato per risolvere il problema del pianificatore si basa su un approccio logico-funzionale, implementato all'interno del linguaggio \texttt{Fabula}. Il sistema utilizza il metodo della forward chaining per generare piani a partire da un insieme di regole e predicati.

Sono state definite delle regole per le operazioni di base, come ad esempio \texttt{grab} e \texttt{put}, le quali modellano le azioni eseguibili nel dominio dei blocchi. Queste azioni sono rappresentate come predicati logici che il pianificatore utilizza per costruire un percorso di azioni che portano dallo stato iniziale a uno stato obiettivo.
Ogni stato è descritto da una serie di predicati, tra cui \texttt{block}, \texttt{subset} e \texttt{removeElement}, che specificano la relazione tra i blocchi e il loro posizionamento. Quando una regola si applica, vengono eseguite le operazioni necessarie per aggiornare lo stato corrente.
Il pianificatore ha come primo caso il controllo dello stato finale della computazione che potrebbe essere terminata nel caso in cui essa sia un sottoinsieme dello stato corrente.
Durate l'applicazione della forward chaining il pianificatore controlla che esista almeno una regola da poter applicare le cui pre condizioni sono compatibili con lo stato corrente della computazione, dopo aver applicato le post condizioni passa alla fase successiva per trovare la futura azione da applicare. 

Il problema è stato approssimato alla ricerca di un percorso all'interno di un grafo.
Esistono diverse strategie per scegliere quale sia il migliore percorso da seguire per poter arrivare all'obiettivo del goal. La ricerca in profondità prevede di sfruttare la ricorsione per allontanarsi velocemente dalla radice dell'albero di decisione, ha il vantaggio di essere più efficiente a livello spaziale, ma al tempo stesso i piani che vengono generati non sono minimi.
La ricerca in ampiezza al contrario sviluppa l'albero di decisione un livello alla volta, dando in output il percorso minimo per arrivare al goal, ma con lo svantaggio di dover mantenere in memoria i nodi che sono già stati attraversati.
Una tecnica che riesce a sfruttare le caratteristiche di entrambe è la ricerca iterativa in profondità, in cui viene effettuata una DFS imponendo un limite di profondità massima, se non si è arrivati ad un piano completo si itera la ricerca, aumentando il limite.

\paragraph{Strutture dati.} La base del pianificatore sono le azioni, funzioni che hanno il compito di aggiornare lo stato corrente della computazione sfruttando quelle che sono le necessarie pre e post condizioni. Le funzioni hanno arietà 3 e hanno danno come input i blocchi da cui da cui partire, lo stato Iniziale prima della computazione, lo stato finale dopo l'esecuzione dell'azione e il piano corrente. L'output sarà il piano aggiornato tramite una \texttt{append/2}.
Le azioni accettano come input lo stato del mondo corrente e quello finale prefissato, in entrambi i casi si tratta di una lista contenente i predicati descritti in precedenza.
Il Piano a sua volta sarà sempre una lista di stati in cui però verranno inserite le azioni effettuate dal pianificatore per arrivare allo stato finale, il piano è frutto delle pre e post condizioni presenti nelle regole.

Per velocizzare la computazioni si possono avere strutture di supporto come degli stack che contengono gli stati già visitati in precedenza per non incorrere in dei loop infiniti.

\paragraph{Funzioni.} All'utente finale verranno esposte 2 funzioni trace/3 e trace\_limit/4. La prima funzione pubblica andrà ad applicare in moto iterativo le varie azioni finché non si otterrà un risultato che verrà dato sotto forma di piano. La signature della funzione prevede di inserire lo stato di partenza, lo stato finale a cui si vuole arrivare e il piano che successivamente dovrà essere letto. La computazione si fermerà quando lo stato corrente sarà un sottoinsieme dello stato finale.

\begin{lstlisting}
ᐅ trace/3 function first case
trace(Stato, StatoFinale, Piano) = Piano
    if subset(StatoFinale, Stato)
ᐅ trace/3 function second case
trace(Stato, StatoFinale, Piano) = Piano2
    if Piano1 = try_action(Stato, StatoNuovo, Piano),
       Piano2 = trace(StatoNuovo, StatoFinale, Piano1)
\end{lstlisting}

Dato la natura esponenziale della computazione è stata idea anche la seconda funzione che introduce un quarto input che consiste in un contatore che forza il programma a cercare una soluzione con soltanto un numero prestabilito di passi.

\begin{lstlisting}
ᐅ trace_limit/3 function first case
trace_limit(Stato, StatoFinale, Piano, N) = Piano
    if subset(StatoFinale, Stato)

ᐅ trace_limit/3 function first case
trace_limit(Stato, StatoFinale, Piano, N) = Piano2
    if N > 0,
       Piano1 = try_action(Stato, StatoNuovo, Piano),
       Piano2 = trace_limit(StatoNuovo,
                            StatoFinale, 
                            Piano1, N-1)
\end{lstlisting}

Una ricerca iterativa in profondità può essere ottenuta tramite le seguenti funzioni, bisognerà partire da un limite iniziale, per esempio 0.

\begin{lstlisting}
ᐅ planIter function
planIter(StatoIniziale, StatoFinale, N) =
    try_plan(StatoIniziale, StatoFinale, N)

ᐅ planIter private function first case
try_plan(StatoIniziale, StatoFinale, N) =
    trace_limit(StatoIniziale, StatoFinale, [], N)

    ᐅ planIter private function second case
try_plan(StatoIniziale, StatoFinale, N) =
    planIter(StatoIniziale, StatoFinale, N + 1)
\end{lstlisting}

Le funzioni private prevedono le regole da applicare nella computazione e una funzione di supporto chiamata try\_action il cui scopo è quello di provare iterativamente ogni regola. Gli input saranno lo stato iniziale, lo stato finale/obiettivo e il piano corrente.

\begin{lstlisting}
ᐅ try_action private function first case
try_action(StatoIniziale, StatoFinale, Plan)
    = putOnTable(X, StatoIniziale, StatoFinale, Plan)
    
ᐅ try_action private function second case
try_action(StatoIniziale, StatoFinale, Plan)
    = grab(X, StatoIniziale, StatoFinale, Plan)
    
ᐅ try_action private function third case
try_action(StatoIniziale, StatoFinale, Plan)
    = put(X, Y, StatoIniziale, StatoFinale, Plan)
    
ᐅ try_action private function fourth case
trace_limit(Stato, StatoFinale, Piano, N) = Piano
    if subset(StatoFinale, Stato)
\end{lstlisting}

Successivamente propongo una implementazione delle funzioni che hanno come obiettivo  l'implementare le 3 azioni necessarie per poter usare il pianificatore. Queste funzioni modellano le azioni di afferrare, posizionare su un altro blocco e posizionare sul tavolo. Ciascuna funzione opera prendendo uno stato iniziale, uno stato finale e un piano d'azione da aggiornare, eseguendo le modifiche necessarie allo stato e generando una sequenza di azioni da seguire.
\begin{lstlisting}
ᐅ grab/4 function private function
grab(X, StatoIniziale, StatoFinale, Plan) = 
    append(Plan, [grab(Stato)])
   if block(X),
    Stato = X,
    subset([empty, clear(X)],StatoIniziale),
    StatoFinaleIntermedio = append(StatoIniziale, 
                                  [holding(X)]),
    StatoFinale = removeElement(StatoFinaleIntermedio, 
                                [empty])
\end{lstlisting}
La funzione \texttt{grab} rappresenta l'azione di afferrare un blocco X da uno stato iniziale. Le condizioni iniziali richiedono che X debba essere un blocco, lo stato iniziale debba contenere un tavolo vuoto e il blocco X debba essere libero da altri oggetti.
\begin{lstlisting}
ᐅ put/5 function private function
put(X, Y, StatoIniziale, StatoFinale, Plan) = 
    append(Plan, [put(Stato)])
    if block(X),
    block(Y),
    Y ≠ X,
    Stato = [X, Y],
    subset([holding(X), clear(Y)], StatoIniziale),
    StatoFinaleIntermedio = append(StatoIniziale, 
                                   [on(X, Y), 
                                   clear(X), 
                                   empty]),
    StatoFinale = removeList(StatoFinaleIntermedio, 
                            [holding(X), 
                            clear(Y)])
\end{lstlisting}
La funzione \texttt{put} modella l'azione di posizionare il blocco X sopra il blocco Y. Le condizioni iniziali richiedono che sia X sia Y siano blocchi distinti e che Y sia libero da altri blocchi, mentre X deve essere già in mano.
\begin{lstlisting}
ᐅ putOnTable/4 private function
putOnTable(X, StatoIniziale, StatoFinale, Plan) = 
append(Plan, [putOnTable(Stato)])
    if block(X),
    Stato = X,
    subset([holding(X)], StatoIniziale),
    StatoFinaleIntermedio = append(StatoIniziale, 
                                  [onTable(X), 
                                  clear(X), 
                                  empty]),
    StatoFinale = removeElement(StatoFinaleIntermedio, 
                                [holding(X)])
\end{lstlisting}
La funzione \texttt{putOnTable} descrive l'azione di posizionare il blocco X sul tavolo. Le condizioni iniziali richiedono che X sia blocco e sia già in mano.


\paragraph{Esempi.} 


Esempi di operazioni con il piano di esecuzione.


\begin{enumerate}
    \item \textbf{Esempio 1: Somma di un polinomio con un valore costante}
    \begin{itemize}
        \item \texttt{x + 32} come risultato si ottiene  \texttt{poly(x,0,[k(0,32)])}
        \item Descrizione: La somma di \( x \) con 32 risulta in un polinomio di grado 0 con coefficiente \( k(0, 32) \).
    \end{itemize}
    
    \item \textbf{Esempio 2: Somma di due polinomi}
    \begin{itemize}
        \item \texttt{poly(x,0,[k(0,32)]) + poly(x,0,[k(0,32)])} come risultato si ottiene \texttt{poly(x,0,[k(0,64)])}
        \item Descrizione: La somma di due polinomi \( poly(x, 0, [k(0,32)]) \) porta ad un nuovo polinomio di grado 0 con coefficiente \( k(0, 64) \).
    \end{itemize}
    
    \item \textbf{Esempio 3: Prodotto di due polinomi}
    \begin{itemize}
        \item \texttt{poly(x,1,[k(0,2), k(1,2)]) * poly(x,1,[k(0,2), k(1,2)])} come risultato si ottiene \texttt{poly(x,2,[k(0,4),k(1,8),k(2,4)])}
        \item Descrizione: Il prodotto di due polinomi di grado 1 produce un polinomio di grado 2, con i coefficienti risultanti dalla moltiplicazione dei termini dei polinomi originali.
    \end{itemize}
    
    \item \textbf{Esempio 4: Derivata di un polinomio}
    \begin{itemize}
        \item \texttt{diff(poly(x,2,[k(0,1), k(1,2), k(2,4)]))} come risultato si ottiene \texttt{poly(x,1,[k(0,2),k(1,8)])}
        \item Descrizione: La derivata di un polinomio di grado 2 porta ad un polinomio di grado 1 con coefficienti derivati dai termini del polinomio originale.
    \end{itemize}
\end{enumerate}


% trace_limit( [clear(b1), onTable(b1), clear(b2), onTable(b2), empty],[on(b1, b2), empty], Piano, 10)
% [grab(b1),put([b1,b2])]
% [grab(b1),put([b1,b2]),grab(b1),putOnTable(b1),grab(b1),putOnTable(b1),grab(b1),putOnTable(b1)]

\cleardoublepage

\section*{Esercizio 3}

\paragraph{Problema.} Il problema consiste nella creazione di un interprete capace di comprendere e processare frasi in linguaggio naturale riguardanti la posizione di blocchi su un tavolo. Il programma raggiunge questo obiettivo attraverso un parser che converte la frase in un albero sintattico astratto (AST) e, successivamente, semplifica tale struttura nella sua forma logica finale. Questo processo avviene utilizzando regole di inferenza per identificare gli oggetti in base alle loro proprietà. Infine, sarà possibile analizzare l'AST e rispondere a domande poste dall'utente.

\paragraph{Metodo.} La creazione dell'interprete, basato su un albero di sintassi astratta, richiede di suddividere il problema in due sotto-problemi principali: \begin{itemize} 
\item Un parser, definito tramite il predicato tell/2, capace di interpretare le frasi di input e generare un albero di sintassi astratta, dal quale derivare i fatti relativi al micromondo. 
\item Un ragionatore, in grado di utilizzare i fatti del micromondo per comporre frasi coerenti sulle informazioni in suo possesso. 
\end{itemize}

Per semplificare lo sviluppo del parser, si utilizzerà un micromondo che segue la grammatica inglese. Un micromondo è un ambiente limitato, con regole ben definite; in questo caso, si adotterà l’ambiente dei blocchi, già noto dai precedenti esercizi.

L'output del parser sarà nel medesimo formato della base di conoscenza utilizzata nel ragionatore per la pianificazione dell'esercizio 2. In un possibile approfondimento successivo, si potrebbero integrare parser e pianificatore per consentire l'inserimento in linguaggio naturale delle informazioni necessarie a individuare un percorso nel mondo dei blocchi.

\paragraph{Strutture dati.} La principale struttura dati utilizzata nell'esercizio è l'albero di sintassi astratta (AST in Inglese) che consiste in un albero binario gerarchico dove viene rappresentato il modo astratto la sintassi del testo che gli viene dato come input.

La struttura AST di \texttt{[the, red, block, is, on, b1]} può essere scritta formalmente come:

\[
[\text{on}(\text{object}(\text{block},[attribute(color,red)]),\text{object}(b1,[]))]
\]

Questa struttura può essere rappresentata graficamente come un albero:

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    level 1/.style={sibling distance=50mm},
    level 2/.style={sibling distance=90mm},
    level 3/.style={sibling distance=40mm},
    every node/.style={align=center}
]
\node {Lista}
    child {
        node {[]}
    }
    child {
        node {on}
        child {
            node {object}
            child {
                node {block}
            }
            child {
                node {[attribute]}
                child {
                    node {color}
                }
                child {
                    node {red}
                }
            }
        }
        child {
            node {object}
            child {
                node {b1}
            }
            child {
                node {[]}
            }
        }
    };
\end{tikzpicture}
\caption{Rappresentazione ad albero della struttura AST per la relazione on()}
\label{fig:ast_structure}
\end{figure}


\paragraph{Funzioni.} Le funzioni che vengono esposte all'utente sono tell e ask. La prima permette di partire da una frase per arrivare ad un insieme di fatti, la seconda partendo da un insieme di fatti e una domanda permette di ottenere una risposta rispetto al micro mondo che viene descritto dal programma.

Le 2 funzioni che verranno esposte all'utente saranno tell/2 e ask/2. In entrambe le funzioni la prima lista di inuit riguarda la i fatti del mondo che si conoscono fino a quel momento, la seconda conterrà una nuova frase che dovrà essere analizzata. Nel caso della della ask bisognerà dare in output nuovi fatti e nel caso della ask bisognerà rispondere con una frase composta da termini.

\begin{lstlisting}
tell(KnowledgeBase, Sentence) = 
    tell1(KnowledgeBase,Sentence)

ask(KnowledgeBase, Question) = 
    ask1(KnowledgeBase, Question)
\end{lstlisting}

Entrambe le funzioni riportano a 2 funzioni private che implementeranno le funzionalità delle ask e tell. Alla base delle 2 funzioni, come visto nel paragrafo relativa alle strutture dati utilizzate in questo esercizio, è presente una funzione che ha come obiettivo la creazione dell'albero di sintassi astratta basata sull'inglese. 

\begin{lstlisting}
ᐅ AST ᐅa([the, block,is, on, the, table])
a(A) = R
    if np(A) = R1, vp(R1) = R
ᐅ Noun Phrase
np(NP) = R
    if det(NP) = R1, n(R1) = R
ᐅ Verb Phrase
vp(VP) = R
    if abe(VP) = R1, pp(R1) = R
ᐅ Prepositional Phrase
pp(PP) = R
    if PP = [on | R1], np(R1) = R
abe([B | R]) = R
    if be(B)
ᐅ Determiner
det([D | R]) = R
    if determiner(D)
ᐅ Noun Phrase
n([N | R]) = R
    if noun(N)
n(N) = R
    if N = [A, R1 | R], adj(A), noun(R1) 
\end{lstlisting}

Questa prima versione ha come obiettivo quello di restituire come output la lista vuota, se viene riconosciuta tutta la frase, oppure una lista con all'interno la porzione della frase rimanente che non è stata riconosciuta nel processo di analisi.

\begin{lstlisting}
ᐅ AST a([the, block,is, on, the, table])
a(A) = vp(R1, ASTN)
    if [R1, ASTN] = np(A)
c(C) = vp
ᐅ Noun Phrase
np([the | R1]) = n(R1)
ᐅ Verb Phrase
vp([is, on | N], ASTS) = [R, on(ASTS, ASTN)]
    if [R, ASTN] = np(N)
ᐅ Noun Phrase
n([N | R]) = [R, object(C, [])]
    if noun(C, N)
n(N) = [R, object(C, [attribute(T, A)])]
    if N = [A, L | R], adj(T, A), noun(C, L) 
\end{lstlisting}

Questa seconda versione ha come output l'albero di sintassi astratta con anche la possibilità di inserire aggettivi come colori e dimensioni. Tali aggettivi devono essere aggiunti tramite predicati come.

\begin{lstlisting}
ᐅ adj/2
adj(color, yellow)
adj(color, blue)
adj(color, red)
adj(size, small)
adj(size, large)
\end{lstlisting}

La tell/2 accetterà frasi del tipo:

\[
[[ \texttt{b1}, \texttt{is}, \texttt{on}, \texttt{the}, \texttt{table}, \texttt{'.'} ]]
\]



Queste frasi dovranno passare da un processo di preprocessing per eliminare il punto finale ed essere alaborate dalla funzione che crea l'albero di sintassi astratta

\begin{lstlisting}
ᐅ tell1
tell1(KnowledgeBase, Sentence) = simplify_ast(AST)
    if SentenceWithoutPeriod = remove_period(Sentence),
       AST = a(SentenceWithoutPeriod)
\end{lstlisting}

La funzione simplify\_ast/1 prende in input l'albero di sintassi astratta e produce l'ouput che verrà mostrato dalla funzione tell1/2. Per esempio nel caso della precedente esempio sarà sufficiente una funzione come la seguente.

\begin{lstlisting}
ᐅsimplify_ast/1
simplify_ast([[],on(object(X,[]),object(table,[]))]) = 
    [onTable(X)]
\end{lstlisting}

Se gli input presentano degli aggettivi come i colori dei blocchi e le loro dimensioni si possono usare più casi della funzione simplify\_ast/1 per catturare ogni evenienza.

\begin{lstlisting}
ᐅsimplify_ast/1
simplify_ast([[],
              on(object(Obj,[attribute(color,COLOR)]),
              object(table,[]))]) = 
    [onTable(Blocco), color(Blocco, COLOR)]
    if blocchi_generici(Obj),  
        blocks(Blocco), 
        color(Blocco) = COLOR
        
ᐅsimplify_ast/1
simplify_ast([[],
              on(object(Obj,[attribute(size,SIZE)]),
              object(table,[]))]) = 
     [onTable(Blocco), size(Blocco, SIZE)]
     if blocchi_generici(Obj),  
     blocks(Blocco), size(Blocco) = SIZE
\end{lstlisting}

LE versioni più semplici della funzione ask cercano hanno il computo di cercare all'interno della base di conoscenza le informazioni necessarie per finire le frasi.

\begin{lstlisting}
ᐅask1/2
ask(KnowledgeBase, [where, is, Object, '?']) = 
    [Object, is, on, the, table, '.']
    if member(KnowledgeBase, onTable(Object))

ᐅask1/2
ask(KnowledgeBase, [what, color, is, Object, '?']) = 
    [Object, is, Color, '.']
    if member(KnowledgeBase, color(Object, Color))

ᐅask1/2
ask(KnowledgeBase, [where, is, Object2, '?']) = 
    [Object2, is, on, Object1, '.']
    if member(KnowledgeBase, on(Object1, Object2)), 
    Object1 ≠ Object2
\end{lstlisting}

Questa base di partenza permette di scrivere predicati in cui tell e ask sono annidati una dentro l'altra, la prima fornisce alla seconda le informazioni necessarie per scrivere le risposte.


\[
\text{ask}(\text{tell}([], [\texttt{b1}, \texttt{is}, \texttt{on}, \texttt{the}, \texttt{table}, \texttt{'.'}]), [\texttt{where}, \texttt{is}, \texttt{b1}, \texttt{'?'}]) = [\texttt{b1}, \texttt{is}, \texttt{on}, \texttt{the}, \texttt{table}, \texttt{'.'}]
\]



\paragraph{Esempi.}

% a([b1, is, on, the, table]) = [[],on(object(b1,[]),object(table,[]))]
% ask([onTable(b1)], [where, is, b1, '?']) = [b1,is,on,the,table,'.']
% ask([on(b1, b2)], [where, is, b2, '?']) = [b2,is,on,b1,'.']
% tell([], [b1, is, on, the, table, '.'])
% ask(tell([], [b1, is, on, the, table, '.']), [where, is, b1, '?'])

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Operazione} & \textbf{Risultato} \\ \hline
$a([b1, is, on, the, table])$ & $[[],on(object(b1,[]),object(table,[]))]$ \\ \hline
$ask([onTable(b1)], [where, is, b1, '?'])$ & $[b1,is,on,the,table,'.]$ \\ \hline
$ask([on(b1, b2)], [where, is, b2, '?'])$ & $[b2,is,on,b1,'.]$ \\ \hline
$tell([], [b1, is, on, the, table, '.'])$ & (Nessun risultato specificato) \\ \hline
$ask(tell([], [b1, is, on, the, table, '.']), [where, is, b1, '?'])$ & $[b1,is,on,the,table,'.]$ \\ \hline
\end{tabular}
\caption{Esempi di operazioni con la base di conoscenza}
\end{table}


\cleardoublepage

\section*{Esercizio 4}

\paragraph{Problema.} L'obiettivo del problema è quello di creare un calcolatore simbolico in grado di manipolare espressioni matematiche simboliche, con particolare attenzione alle espressioni polinomiali multivariate e a funzionalità come somma, prodotto, derivazione.

Il problema può essere affrontato tramite una rappresentazione densa e sparsa. Successivamente si vedrà una prima rappresentazione compatta a variabile singola, sparsa a variabile singola e sparsa multivariata.

\subsection*{Polinomi in variabile singola}
\paragraph{Rappresentazione:}
\begin{itemize}
    \item \textbf{Versione Densa}: Rappresentazione del polinomio tramite un array con coefficienti per ogni grado.\\
    Esempio: \texttt{poly(x, 4, [4, 7, 0, 0, 9])} rappresenta il polinomio $4 + 7x + 9x^4$.
    \item \textbf{Versione Sparsa}: Rappresentazione dei soli gradi con coefficienti diversi da zero.\\
    Esempio: \texttt{poly(x, 4, [k(0, 4), k(1, 7), k(4, 9)])} rappresenta $4 + 7x + 9x^4$.
\end{itemize}

La prima implementazione è stata effettuata tramite il metodo denso dala la sua semplicità di implementazione grazie alla manipolazione delle liste offerta dai predicati implementabili nel linguaggio.

\paragraph{Operazioni da supportare nel calcolatore:}
\begin{itemize}
    \item \textbf{Somma e Prodotto}: Definite simbolicamente con $+'(X, Y)$ e $*'(X, Y)$.
    \item \textbf{Derivazione}: Calcolo della derivata rispetto a una variabile: $\text{diff}(X, x)$.
\end{itemize}

Per consentire al calcolatore simbolico di interpretare correttamente le espressioni simboliche inserite dall'utente, è necessario implementare un parser. Questo parser traduce i termini in input in un formato comprensibile dal calcolatore. L'implementazione prevede la riscrittura degli operatori \texttt{+}, \texttt{*} e \texttt{\textasciicircum} per gestire tutti i casi in cui è necessario interagire con il predicato \texttt{poly}.


\subsection*{Polinomi in più variabili}
\paragraph{Supporto:}
\begin{itemize}
    \item Polinomi con variabili multiple (es., $x$, $y$, $z$).
    \item Ordinamento delle variabili per la manipolazione: \texttt{ord([x, y, z])} specifica l'ordine di priorità.
\end{itemize}

\paragraph{Esempi di rappresentazione:}
\begin{itemize}
    \item $x^3 + 5y - 1$ è rappresentato come:
    \[
    \text{poly}(x, [-1, \text{poly}(y, [0, 5]), 0, 1])
    \]
    \item $z^4 + 7x + y$ è rappresentato come:
    \[
    \text{poly}(x, [\text{poly}(y, [\text{poly}(z, [0, 0, 0, 0, 1]), 1]), 7])
    \]
\end{itemize}

\paragraph{Metodo.} La prima versione del problema vede la risoluzione delle operazioni base da effettuare sui polinomi con la rappresentazione densa a singola variabile. Tale rappresentazione permette di effettuare con maggiore facilità operazioni di somma e prodotto grazie alla manipolazione delle liste, per facilitare l'approccio il grado viene mantenuto esplicito, successivamente potrebbe essere dedotto tramite funzioni come \texttt{size}.

Per effettuare la somma è sufficiente calcolare quale sia il grado maggiore tra i 2 polinomi, estendere le loro liste se necessario ed effettuare la somma grado per grado.

Nel prodotto il grado del polinomio risultante è dato dalla somma dei gradi dei due polinomi originali. Questo determina la lunghezza della lista dei coefficienti del risultato. Si crea una lista di zeri di lunghezza pari al grado massimo risultante più uno, rappresenta i coefficienti del polinomio risultante. Si itera su tutti i termini del primo polinomio e, per ciascuno di essi, si moltiplica il coefficiente per ciascun termine del secondo polinomio. Il prodotto ottenuto viene aggiunto al termine corrispondente nella lista dei coefficienti del risultato, posizionato all'indice corrispondente alla somma degli esponenti dei due termini moltiplicati. Questo processo viene ripetuto per tutti i termini del primo polinomio e del secondo polinomio, accumulando i valori dei coefficienti nella lista del risultato.

Per la derivata è sufficiente iterare sui coefficienti e diminuire il grado del polinomio.

Successivamente sono passato a una rappresentazione densa. Le operazioni sono simili, ma invece di utilizzare una lista per rappresentare i coefficienti del polinomio, sfrutto un predicato \(k(X, Y)\), dove \(X\) rappresenta il grado del polinomio e \(Y\) il valore del coefficiente corrispondente a quel grado. Una possibile variante potrebbe essere l'utilizzo di liste ricorsive al posto del predicato indicato.

L'ultima versione del programma vede l'utilizzo delle operazioni di somma, prodotto e derivazione su una versione densa dei polinomi in più variabili.


\paragraph{Strutture dati.} Descrizione delle strutture dati utilizzate. 

\paragraph{Funzioni.} All'utente finale vengono esposte funzioni il cui unico scopo è sovrascrivere gli operatori di default messi a disposizione da Fabula per la somma e il prodotto. L'idea è che l'utente possa le operazioni di base messe a disposizione come se fossero operazioni built-in del linguaggio. L'unico nuovo predicato esposto sarà quello dedicato alla derivazione, \( \texttt{diff/1} \).
Successivamente vado a riportare le 3 implementazioni, ognuna presenterà in ordine gli quali operatori sono stati sovrascritti, la funzione per implementare la derivazione, le funzioni di somma/prodotto e se presenti ulteriori funzioni di supporto.

\subparagraph{Densa ad una variabile}

Sovrascrittura degli operatori

Funzione per implementare l'operazione della derivazione

\begin{lstlisting}
diff(poly(x, Grado, Lista)) = 
    poly(x, Grado - 1, ListaDerivata) if
        ListaDerivata = diffList(Lista, 0)

diffList([], _) = []
diffList([H | T], Exp) = 
    diffList(T, Exp + 1) if Exp = 0
diffList([H | T], Exp) = 
    [H * Exp | diffList(T, Exp + 1)] if Exp > 0
\end{lstlisting}

Funzioni private per l'implementazione della somma e prodotto.

\begin{lstlisting}

sum(poly(x, GradoX, ListaX), poly(x, GradoY, ListaY)) = 
    poly(x, MaxGrado, SommaListe) if
        MaxGrado = max(GradoX, GradoY),
        ListaXEstesa = extend(ListaX, MaxGrado + 1),
        ListaYEstesa = extend(ListaY, MaxGrado + 1),
        SommaListe = sumLists(ListaXEstesa, ListaYEstesa)

extend(Lista, Len) = Lista if length(Lista) = Len
extend(Lista, Len) = extend([0 | Lista], Len) 
                    if length(Lista) < Len


prod(poly(x, GradoX, ListaX), poly(x, GradoY, ListaY)) = 
    poly(x, GradoX + GradoY, ProdottoListe) if
        LunghezzaRisultato = GradoX + GradoY + 1,
        ListaZeri = createZeros(LunghezzaRisultato),
        ProdottoListe = 
            prodLists(ListaX, 0, ListaY, ListaZeri)

createZeros(0) = []
createZeros(N) = [0 | createZeros(N - 1)] if N > 0

prodLists([], _, _, Acc) = Acc
prodLists([H1 | T1], Exp1, Lista2, Acc) = 
    prodLists(T1, Exp1 + 1, Lista2, NuovoAcc) if
        TempAcc = prodSingleTerm(H1, Exp1, Lista2, 0, Acc),
        NuovoAcc = TempAcc

prodSingleTerm(_, _, [], _, Acc) = Acc
prodSingleTerm(Coeff1, Exp1, [H2 | T2], Exp2, Acc) = 
    prodSingleTerm(Coeff1, Exp1, T2, Exp2 + 1, NuovoAcc) if
        Prodotto = Coeff1 * H2,
        ExpTotale = Exp1 + Exp2,
        NuovoAcc = updateAtIndex(Acc, ExpTotale, Prodotto)
\end{lstlisting}

Funzioni di supporto

\begin{lstlisting}
updateAtIndex([], _, _) = []
updateAtIndex([H | T], 0, Val) = [H + Val | T]
updateAtIndex([H | T], Idx, Val) = 
    [H | updateAtIndex(T, Idx - 1, Val)] if Idx > 0

sumLists([], []) = []
sumLists([H1 | T1], [H2 | T2]) = 
    [H1 + H2 | sumLists(T1, T2)]

max(X, Y) = X if X > Y
max(X, Y) = Y if Y > X
max(X, Y) = X if X = Y

isPoly(X) = true if X = poly(Var, Grad, Lista)
\end{lstlisting}

\subparagraph{Sparsa ad una variabile}

Sovrascrittura degli operatori
\begin{lstlisting}
'^'(X, Y) = poly(x, Y, [k(Y, 1)]) if X = x, integer(Y)

'+'(x, Number) = poly(x, 0, [k(0, Number)]) 
    if integer(Number)
'+'(Number, x) = poly(x, 0, [k(0, Number)]) 
    if integer(Number)

ᐅ Aggiungere una regola per sommare un polinomio con un intero
'+'(poly(Var, Grado, Lista), Intero) = 
    poly(Var, Grado, NuovaLista) if 
        integer(Intero),
        NuovaLista = mergeSparse(Lista, [k(0, Intero)])

'+'(Intero, poly(Var, Grado, Lista)) = 
    poly(Var, Grado, NuovaLista) if 
        integer(Intero),
        NuovaLista = mergeSparse([k(0, Intero)], Lista)

'+'(X, Y) = Z if 
    isPoly(X),
    isPoly(Y),
    Z = sum(X, Y)

'*'(X, Y) = Z if 
    isPoly(X),
    integer(Y),
    Z = prod(X, poly(x, 0, [k(0, Y)]))

'*'(X, Y) = Z if 
    isPoly(Y),
    integer(X),
    Z = prod(poly(x, 0, [k(0, X)]), Y)

'*'(X, Y) = Z if 
    Z = prod(X, Y),
    isPoly(Z)
\end{lstlisting}

Funzione per implementare l'operazione della derivazione
\begin{lstlisting}
diff(poly(x, Grado, Lista)) = 
    poly(x, Grado - 1, ListaDerivata) if
        ListaDerivata = diffList(Lista)

diffList([]) = []
diffList([k(0,_) | T]) = diffList(T)
diffList([k(E,C) | T]) = 
    [k(E-1, C * E) | diffList(T)] if E > 0
\end{lstlisting}

Funzioni private per l'implementazione della somma e prodotto.
\begin{lstlisting}
sum(poly(x, GradoX, ListaX), poly(x, GradoY, ListaY)) = 
    poly(x, MaxGrado, SommaListe) if
        MaxGrado = max(GradoX, GradoY),
        SommaListe = mergeSparse(ListaX, ListaY)


mergeSparse([], Lista) = Lista
mergeSparse(Lista, []) = Lista
mergeSparse([k(E1,C1) | T1], [k(E2,C2) | T2]) = 
    [k(E1,C1) | mergeSparse(T1, [k(E2,C2) | T2])] if E1 < E2
mergeSparse([k(E1,C1) | T1], [k(E2,C2) | T2]) = 
    [k(E2,C2) | mergeSparse([k(E1,C1) | T1], T2)] if E2 < E1
mergeSparse([k(E,C1) | T1], [k(E,C2) | T2]) = 
    [k(E,C1 + C2) | mergeSparse(T1, T2)]

prod(poly(x, GradoX, ListaX), poly(x, GradoY, ListaY)) = 
    poly(x, GradoX + GradoY, ProdottoListe) if
        LunghezzaRisultato = GradoX + GradoY + 1,
        ListaZeri = createZerosK(LunghezzaRisultato, 0),
        ProdottoListe = prodLists(ListaX, ListaY, ListaZeri)



prodLists([], _, Acc) = Acc
prodLists([k(E1,C1) | T1], Lista2, Acc) = 
    prodLists(T1, Lista2, NuovoAcc) if
        TempAcc = prodSingleTerm(k(E1,C1), Lista2, Acc),
        NuovoAcc = TempAcc

prodSingleTerm(_, [], Acc) = Acc
prodSingleTerm(k(E1,C1), [k(E2,C2) | T2], Acc) = 
    prodSingleTerm(k(E1,C1), T2, NuovoAcc) if
        Prodotto = C1 * C2,
        ExpTotale = E1 + E2,
        NuovoAcc = updateAtIndexK(Acc, ExpTotale, Prodotto)
\end{lstlisting}

Le funzioni di supporto
\begin{lstlisting}
createZerosK(0, _) = []
createZerosK(N, Curr) = 
    [k(Curr,0) | createZerosK(N - 1, Curr + 1)] if N > 0

updateAtIndexK([], _, _) = []
updateAtIndexK([k(E,C) | T], E, Val) = [k(E,C + Val) | T]
updateAtIndexK([k(E,C) | T], Idx, Val) 
    = [k(E,C) | updateAtIndexK(T, Idx, Val)] if E < Idx

max(X, Y) = X if X > Y
max(X, Y) = Y if Y > X
max(X, Y) = X if X = Y
\end{lstlisting}

\subparagraph{Sparsa a più di una variabile}

\paragraph{Esempi.} Descrizione di alcuni esempi di utilizzo.

\subparagraph{Densa a una variabile}

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
\textbf{Operazione} & \textbf{Risultato} \\ \hline
$\texttt{poly(x,0,[10]) + poly(x,0,[10])}$ & $\texttt{poly(x,0,[20])}$ \\ \hline
$\texttt{poly(x,0,[10]) * poly(x,0,[10])}$ & $\texttt{poly(x,0,[100])}$ \\ \hline
$\texttt{poly(x,1,[10, 10]) * poly(x,0,[10])}$ & $\texttt{poly(x,1,[100,100])}$ \\ \hline
$\texttt{poly(x,4,[0,0,0,1]) + poly(x,4,[0,0,0,1])}$ & $\texttt{poly(x,4,[0,0,0,0,2])}$ \\ \hline
$\texttt{poly(x,4,[1,0,0,1]) + poly(x,4,[9,0,0,1])}$ & $\texttt{poly(x,4,[0,10,0,0,2])}$ \\ \hline
$\texttt{poly(x,4,[1,2,3,4]) * poly(x,4,[1,2,3,4])}$ & $\texttt{poly(x,8,[1,4,10,20,25,24,16,0,0])}$ \\ \hline
$\texttt{diff(poly(x,4,[1,2,3,4]))}$ & $\texttt{poly(x,3,[2,6,12])}$ \\ \hline
\end{tabular}
\caption{Esempi di operazioni sui polinomi}
\label{tab:operazioni-polinomi}
\end{table}

\subparagraph{Sparsa a una variabile}


\begin{enumerate}
    \item \textbf{Esempio 1: Somma di un polinomio con un valore costante}
    \begin{itemize}
        \item \texttt{x + 32} come risultato si ottiene \texttt{poly(x,0,[k(0,32)])}
        \item Descrizione: La somma di \( x \) con 32 risulta in un polinomio di grado 0 con coefficiente \( k(0, 32) \).
    \end{itemize}
    
    \item \textbf{Esempio 2: Somma di due polinomi}
    \begin{itemize}
        \item \texttt{poly(x,0,[k(0,32)]) + poly(x,0,[k(0,32)])} come risultato si ottiene \\ \texttt{poly(x,0,[k(0,64)])}
        \item Descrizione: La somma di due polinomi \( poly(x, 0, [k(0,32)]) \) porta ad un nuovo polinomio di grado 0 con coefficiente \( k(0, 64) \).
    \end{itemize}
    
    \item \textbf{Esempio 3: Prodotto di due polinomi}
    \begin{itemize}
        \item \texttt{poly(x,1,[k(0,2), k(1,2)]) * poly(x,1,[k(0,2), k(1,2)])} come risultato si ottiene \texttt{poly(x,2,[k(0,4),k(1,8),k(2,4)])}
        \item Descrizione: Il prodotto di due polinomi di grado 1 produce un polinomio di grado 2, con i coefficienti risultanti dalla moltiplicazione dei termini dei polinomi originali.
    \end{itemize}
    
    \item \textbf{Esempio 4: Derivata di un polinomio}
    \begin{itemize}
        \item \texttt{diff(poly(x,2,[k(0,1), k(1,2), k(2,4)]))} come risultato si ottiene \\ \texttt{poly(x,1,[k(0,2),k(1,8)])}
        \item Descrizione: La derivata di un polinomio di grado 2 porta ad un polinomio di grado 1 con coefficienti derivati dai termini del polinomio originale.
    \end{itemize}
\end{enumerate}

% x+32 -> poly(x,0,[k(0,32)])
% poly(x,0,[k(0,32)]) + poly(x,0,[k(0,32)]) -> poly(x,0,[k(0,64)])
% poly(x,1,[k(0,2), k(1,2)]) * poly(x,1,[k(0,2), k(1,2)]) -> poly(x,2,[k(0,4),k(1,8),k(2,4)])
%diff(poly(x,2,[k(0,1), k(1,2), k(2,4)])) -> poly(x,1,[k(0,2),k(1,8)])
\subparagraph{Sparsa a più di una variabile}

\cleardoublepage


\section*{Esercizio 5}

\paragraph{Problema.} Descrizione del problema affrontato.

\paragraph{Metodo.} Descrizione degli algoritmi utilizzati per la risoluzione del problema.

\paragraph{Strutture dati.} Descrizione delle strutture dati utilizzate. 

\paragraph{Funzioni.} Descrizione delle funzioni realizzate specificando anche quali sono pubbliche e quali sono private.

\paragraph{Esempi.} Descrizione di alcuni esempi di utilizzo.

\cleardoublepage


\section*{Appendice}
\paragraph{Forward Chaining} Iniziando dai dati disponibili e usa le regole di inferenza per ricavare ulteriori dati fino al raggiungimento di un certo obiettivo. Un motore inferenziale che usa Forward Chaining ad ogni passo va alla ricerca delle regole di inferenza tali per cui la premessa è nota essere vera, dopodiché può dedurre la conseguenza e aggiungerla come nuovo dato a disposizione.
\paragraph{Background Chaining} Iniziando da una lista di obiettivi (o ipotesi) e ragiona in modo inverso rispetto alla Forward Chaining, partendo dalle conseguenze delle regole di inferenza disponibili e verificando se le premesse sono note essere vere.

\section*{Funzioni frequentemente utilizzate all'interno del documento}

Le seguenti funzioni di supporto eseguono operazioni ricorrenti nella risoluzione del problema e sono state implementate per facilitare il loro riutilizzo in futuro.
\paragraph{member/2}
Funzione per controllare se un elemento è presente all'interno di una lista.
\begin{lstlisting}
ᐅ member/2 pravate function 
member([H | _], H) = true
member([_ | T], H) = member(T, H)
\end{lstlisting}

\paragraph{anyMember/2}
Funzione per controllare se almeno un elemento del primo membro è presente nel secondo, sfrutta la funzione member/2.
\begin{lstlisting}
ᐅ anyMember/2 pravate function
anyMember([H | _], L) = true if member(L, H)
anyMember([_ | T], L) = anyMember(T, L)
\end{lstlisting}

\paragraph{subset/2}
Funzione per constatare se una lista è completamente contenuta in un'altra, utile quando bisogna confrontare 2 insiemi.
\begin{lstlisting}
ᐅ subset/2 pravate function
subset([], _) = true
subset([H | T], S) if member(S, H), subset(T, S)
\end{lstlisting}

\paragraph{andList/2}
Funzione per trasformare uno o più \texttt{and} annidati in una lista.
\begin{lstlisting}
ᐅ andList/2 pravate function
andList(P) = andList1(P, [])
andList1(A, L)         = [A | L] if symbol(A)
andList1(and(A, B), L) = andList1(A, andList1(B, L))
\end{lstlisting}

\paragraph{orList/2}
Funzione per trasformare uno o or \texttt{or} annidati in una lista.
\begin{lstlisting}
ᐅ orList/2 pravate function
orList(P) = orList1(P, [])
orList1(A, L)         = [A | L] if symbol(A)
orList1(or(A, B), L) = orList1(A, orList1(B, L))
\end{lstlisting}

\paragraph{normalizeNot/1}
Funzione che ha il compito di gestire il caso in cui una proposizione sia doppiamente negata.
\begin{lstlisting}
normalizeNot(not(not(P))) = P
normalizeNot(not(P)) = not(P)
normalizeNot(P) = P
\end{lstlisting}

\paragraph{removeElement/1}
Funzione  per rimuovere un elemento da una lista.
\begin{lstlisting}
removeElement([H | T], [H]) = T
removeElement([H | T], [X]) = [H | removeElement(T, [X])]
\end{lstlisting}

\paragraph{removeList/1}
Funzione per rimuovere una sottolista da un'altra lista.
\begin{lstlisting}
removeList(Stato, []) = Stato
removeList(Stato, [H | T]) = 
        removeList(removeElement(Stato, [H]), T)
\end{lstlisting}

\paragraph{checkNoDuplicates/1}
Funzione per controllare la presenza di un elemento duplicato all'interno di un piano.
\begin{lstlisting}
checkNoDuplicates(PlanParziale, Plan) = true
    if not_member(PlanParziale, Plan)
\end{lstlisting}

\paragraph{not\_member/1}
Funzione per controllare iterativamente che ogni elemento della prima lista non sia presente nella seconda.
\begin{lstlisting}
not_member([], _) = true
not_member([H | T], Plan) = not_member(T, Plan)
    if not_in(H, Plan)
\end{lstlisting}

\paragraph{not\_in/1}
Funzione di appoggio per controllare che un elemento non faccia parte di una lista.
\begin{lstlisting}
not_in(_, []) = true
not_in(X, [H | T]) = not_in(X, T)
    if X ≠ H
\end{lstlisting}

\paragraph{remove\_period/1}
Funzione che prende in input una lista contenente dei termini ed elimina il punto finale se presente.
\begin{lstlisting}
remove_period(['.']) = []
remove_period([X | Rest]) = [X | remove_period(Rest)]
\end{lstlisting}
Nei vari esercizi nel caso in cui venissero utilizzate funzioni private con la medesima firma non verranno riproposte una seconda volta e verrà utilizzato il precedente elenco come riferimento per la loro implementazione


\end{document}
