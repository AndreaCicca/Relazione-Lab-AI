ᐅ Somma
ᐅ poly(x,[k(0,poly(y,[k(0,poly(z,[k(0,8),k(1,6)])),k(1,3)])),k(1,3),k(2,1)])

ᐅ Da quardare: poly(y,[ k(0,4), k(1,7), k(4,9)]) + poly(y,[ k(0,4), k(1,7), k(4,9)]), non gli piace quando non comincia con x

'^'(X, Y) = poly(X, [k(Y, 1)]) if var(X), integer(Y)

ᐅ Somma

toPoly(Number) = poly(x, [k(0, Number)])
toPoly(VAR) = poly(VAR, [k(0, 1)])
toPoly(poly(Var, Lista)) = promoteToX(poly(Var, Lista))

'+'(X, Y) = sum(toPoly(X), toPoly(Y))

'+'(X, Y) = sum(X_promoted, Y_promoted)
    if isPoly(X),
    isPoly(Y),
    X_promoted = promoteToX(X),
    Y_promoted = promoteToX(Y)

ᐅ caso simbolo + poly

'+'(X, poly(Var, Lista)) = 
    sum(poly(X, [k(0, 1)]), poly(Var, Lista)) if
    var(X),
    var(Var)

'+'(poly(Var, Lista), X) = 
    sum(poly(Var, Lista), poly(X, [k(0, 1)])) if
    var(X),
    var(Var)

var(x)
var(y)
var(z)

promoteToX(poly(x, Lista)) = poly(x, Lista)
promoteToX(poly(y, Lista)) = poly(x, [k(0, poly(y, Lista))])
promoteToX(poly(z, Lista)) = poly(x, [k(0, poly(y, [k(0, poly(z, Lista))]))])

isPoly(X) if X = poly(Var, Lista)

ordinePrecedenza(x, y)
ordinePrecedenza(x, z)
ordinePrecedenza(y, z)



ᐅ member/1
member([H | _]) = H
member([_ | R]) = member(R)

sum(poly(Var1, Lista1), poly(Var2, Lista2)) = 
    poly(Var1, NuovaLista) if
        Var1 ≠ Var2,
        ordinePrecedenza(Var1, Var2),
        NuovaLista = [k(0, poly(Var2, Lista2)) | Lista1]

sum(poly(x, ListaX), poly(x, ListaY)) = 
    poly(x, NuovaLista) if
        NuovaLista = mergeSparseMultivar(ListaX, ListaY)


ᐅ Derivata
diff(poly(x, Lista)) = 
    poly(x, ListaDerivata) if
        ListaDerivata = diffListMultivar(Lista)

diffListMultivar([]) = []
diffListMultivar([k(0, _) | T]) = diffListMultivar(T)
diffListMultivar([k(E, C) | T]) = 
    [k(E-1, C * E) | diffListMultivar(T)] if 
        E > 0,
        integer(C)
    
diffListMultivar([k(E, poly(Var, SubLista)) | T]) = 
    [k(E-1, poly(Var, SubListaDerivata)) | diffListMultivar(T)] if
        SubListaDerivata = diffListMultivar(SubLista),
        E > 0


mergeSparseMultivar([], Lista) = Lista
mergeSparseMultivar(Lista, []) = Lista
mergeSparseMultivar([k(E,C1)], [k(E,C2)]) = [k(E, C1 + C2)]
mergeSparseMultivar([k(E1,C1), k(E1,C2) | RestX], Lista) = 
    mergeSparseMultivar([k(E1, C1 + C2) | RestX], Lista)
mergeSparseMultivar(Lista, [k(E1,C1), k(E1,C2) | RestY]) = 
    mergeSparseMultivar(Lista, [k(E1, C1 + C2) | RestY])
mergeSparseMultivar([k(E1,C1) | T1], [k(E2,C2) | T2]) = 
    [k(E1,C1) | mergeSparseMultivar(T1, [k(E2,C2) | T2])] if E1 < E2
mergeSparseMultivar([k(E1,C1) | T1], [k(E2,C2) | T2]) = 
    [k(E2,C2) | mergeSparseMultivar([k(E1,C1) | T1], T2)] if E2 < E1
mergeSparseMultivar([k(E,C1) | T1], [k(E,C2) | T2]) = 
    [k(E, C1 + C2) | mergeSparseMultivar(T1, T2)]



ᐅ Devo sistemare questa funzione perchè attualmente da in output [k(2,1),k(1,3),[[k(0,8),k(1,6)],k(1,3)]]

extractCoefficients(poly(_, Lista)) = extractCoefficientsFromList(Lista)

extractCoefficientsFromList([]) = []
extractCoefficientsFromList([k(_,poly(_,SubLista)) | T]) = 
    [extractCoefficientsFromList(SubLista) | extractCoefficientsFromList(T)]
extractCoefficientsFromList([k(E,C) | T]) = 
    [k(E,C) | extractCoefficientsFromList(T)]

reverseLists(Lista) = reverseHelper(Lista, [])

reverseHelper([], Acc) = Acc
reverseHelper([H | T], Acc) = reverseHelper(T, [H | Acc])

mergeTwoSparseMultivar([], []) = []
mergeTwoSparseMultivar([H1 | T1], [H2 | T2]) = 
    [Merged | Rest] if
        Merged = mergeSparseMultivar(H1, H2),
        Rest = mergeTwoSparseMultivar(T1, T2)
mergeTwoSparseMultivar([H1 | T1], []) = [H1 | mergeTwoSparseMultivar(T1, [])]
mergeTwoSparseMultivar([], [H2 | T2]) = [H2 | mergeTwoSparseMultivar([], T2)]

ᐅ Creare la funzione che passando da [[k(2,1),k(1,3)],[[k(0,8),k(1,6)],k(1,3)]] mi crea il poly() corretto